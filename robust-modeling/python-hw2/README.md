[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-f059dc9a6f8d3a56e377f745f24479a46679e63a5d9fe6f495e02850cd0d8118.svg)](https://classroom.github.com/online_ide?assignment_repo_id=5753093&assignment_repo_type=AssignmentRepo)
# python-hw-2

Для каждой задачи есть заранее подготовленный файл в папке `solutions/`.
Решения необходимо добавить в соответствующие файлы.

Для локального запуска тестов сначала необходимо установить зависимости: `pip install -r requirements.txt`

После чего нужно выполнить `python -m pytest`.

# Материалы для чтения

1. Еще раз о классах - https://docs.python.org/3/tutorial/classes.html
1. Про волшебные методы - https://dbader.org/blog/python-dunder-methods
1. Прочитать про ограничения на перегрузку спец. методов - https://docs.python.org/3/reference/datamodel.html#object.__getattr__
1. Выборочно почитать про объектную модель в питоне, выяснить непонятные для себя моменты - https://docs.python.org/3/reference/datamodel

# Task 1

Реализовать генератор чисел Фибоначчи.

## Описание

### Пример работы
```python
g = fib()
next(g) # == 0
next(g) # == 1
next(g) # == 1
next(g) # == 2
...

```


# Task 2

## Описание

Реализовать генератор, который принимает на вход конечное число списков целых чисел, а возвращает
сначала все четные элементы, а потом все нечетные элементы из всех списков.

### Пример работы
```python
g = even_odd([1,2,3], [4,5,6])
next(g) # == 2
next(g) # == 4
next(g) # == 6
next(g) # == 1
next(g) # == 3
next(g) # == 5
next(g) # raises StopIteration
...

```

### Примечание

Наивное решение может не пройти по времени. Задачу можно эффективно решить при помощи:
1. https://docs.python.org/3/library/itertools.html#itertools.tee
1. https://docs.python.org/3/library/itertools.html#itertools.chain


# Task 3

## Описание

Реализовать функцию `counter`, которая первым параметром получает некоторый класс,
а остальные параметры применяет для создания экземпляра этого класса.

Функция должна возвращать 4 отсортированных списка:
1. имена методов класса
1. имена полей класса
1. имена методов, которые появились в экземпляре (т. е. в классе их не было, а при создании экземпляра они появились)
1. имена полей, которые появились в экземпляре (под «полями» имеются в виду не-callable() атрибуты).

### Пример работы
```python
class C:
    x, y, z = 1, 3, 5

    def X(self): return self.x
    def Y(self): return self.y

    def __init__(self, dx, dy, dz):
        self.x = dx
        self.Y = dy
        self.Z = dz

cm, cf, om, of = counter(C, 6, 7, 8)
# cm == [X, Y]
# cf == [x, y, z]
# om == []
# of == [Y Z]
```


# Task 4

## Описание

Написать класс C, экземпляры которого:

1. можно создать из чего угодно (в т. ч. из ничего)
1. можно индексировать по любому значению (возвращается объект, который использовался в качестве индекса)
1. позволяют выполнить присваивание и удаление элементов по индексу (эта операция не делает ничего)
1. содержат любое поле (возвращается имя этого поля)
1. позволяют присваивать и удалять поля (эта операция не делает ничего)
1. итерируемы (последовательность всегда пуста)
1. в виде строки представляются как "C"

### Входные данные
```python
M, N = C(), C(1,2,3,4)
print(M, N) # "C C"
M[13] = N.abc = 37
print(M[13], N.abc) # 13 abc
print(*list(C("ABCBA"))) # prints empty string
del M["QQ"], N[6:10], M[...], N._
print(M.adhd, N[-2]) # adhd -2
```


# Task 5

## Описание

Реализовать класс StringMinus, который бы полностью воспроизводил поведение встроенного класса str,
но дополнительно поддерживал бы операцию вычитания строк.

Вычитание работает по следующему правилу:
уменьшаемое просматривается посимвольно, если текущий символ присутствует в вычитаемом, то он однократно удаляется из обеих строк.

### Пример работы
```python
StringMinus("qwertyerty") - StringMinus("ttttr") == "qweyery" # True
```


# Task 6

## Описание

Написать параметрический декоратор `MyPy`, который принимает первым аргументом последовательность типов (`args_types`),
а вторым тип результата работы функции (`res_type`). Он должен бросать исключение TypeError при вызове функции со следующим сообщением:

- "Type of argument Номер is not Тип", если не совпадает тип позиционного параметра функции и соответствующий ему по порядку тип в args_types
- "Type of argument Имя is not Тип", если не совпадает тип именного параметра функции и соответствующий ему тип в args_types. Типы именованных параметров перечислены в конце args_types в порядке их описания в сигнатуре декорируемой функции.
- "Type of result is not Тип", если тип возвращённого функцией значения не совпадает с res_type
- "Function Функция must have Число arguments", если количество переданных функции параметров (включая переданные по умолчанию) не соответствует длине args_types

Сначала проверяются параметры в порядке описания в функции, затем вызывается функция, после чего проверяется результат.
Исключение возникает при первом несовпадении типа.

### Пример работы
```python

```

### Примечание

Кратко про *args, **kwargs и декораторы: https://www.ritchieng.com/python/decorators-kwargs-args/

Параметрический декоратор отличается от обычного тем, что принимает аргументы и возвращает декоратор (то есть функцию).
Получается своего рода конструктор декораторов.

Пример параметрического декоратора:

```python
def times(times):
    def inner(func):
        def newfunc(*args):
            return [func(*args) for i in range(times)]
        return newfunc
    return inner

@times(5)
def say_hi():
    return "hi"

print(*say_hi()) # print hi 5 times
```

---

## Источники

Помимо указанных в тексте ссылок, для создания курса и домашних заданий частично были использованы материалы
курса по питону от [Григория Владимировича Курячего](https://uneex.org/FrBrGeorge).